

인접한 원소(i번쨰 원소와 (i+1)번째 원소)를 검사하여 정렬하는 알고리즘. 선택 정렬과 비슷한 부분이 있다.

- 버블 정렬 코드
    
    ```Java
    public static void main(String[] args) {
    	int[] arr = {5, 28, 59, 12, 50, 60, 2, 15, 38, 69};
    	int temp;
    
    	System.out.print("기존 배열: ");
    	for (int i = 0; i < arr.length; i++)
    		System.out.print(arr[i]+ " " );
    	System.out.println();
    
    	for (int i = arr.length; i > 0; i--) {
    		//뒤에서부터 가장 큰 값이 정해진다.
    		for (int j = 0; j < i - 1; j++) {
    			//이미 정해진 값을 제외하고 반복문 실행
    			if (arr[j] > arr[j+1]) {
    				//j번쨰 요소와 j+1번째 요소를 비교해 교환
    				temp = arr[j];
    				arr[j] = arr[j+1];
    				arr[j+1] = temp;
    			}
    		}
    	}
    
    	System.out.print("정렬 후 배열: ");
    	for (int i = 0; i < arr.length; i++) {
    		System.out.print(arr[i]+ " " );
    	}
    }
    ```
    
    기존 배열: 5 28 59 12 50 60 2 15 38 69  
    정렬 후 배열: 2 5 12 15 28 38 50 59 60 69  
    
      
    
      
    
      
    

모든 경우를 다 비교하기 때문에 시간복잡도는 최선, 최악의 상황 모두 동일하게 O(n^2)이다.

공간 복잡도는 한 배열 안에서 일어나기 때문에 O(n)이지만 교환이 많이 일어나(3번씩) 선호되는 정렬이 아니다.