
John Von Neumann이 제안한 정렬 알고리즘. 분할 정복(Divide Conquer) 알고리즘이며 재귀 함수(Recursive Function)을 사용한다. 추가적인 배열이 필요하다.

분할 정복(Divide Conquer): 배열을 두 개로 나눠 각각 해결한 뒤 결과를 병합한다.

길이가 1이나 0이 남으면 정렬 된 것으로 간주한다.(배열이 1개면 정렬된 것)

정렬되지 않은 배열을 비슷한 크기로 계속 나눠간다. 그리고 그 둘의 배열을 비교해 새로운 배열에 집어넣는다.

  

![[Untitled 20.png|Untitled 20.png]]

병합 정렬의 요소

first: 주어진 범위의 첫번째 인덱스

last: 주어진 범위의 마지막 인덱스

mid: 주어진 범위의 중앙 인덱스((first + last) / 2)

- 병합 정렬 코드
    
    ```Java
    public class MergeSort extends Sort{
        public static void main(String[] args) {
            Random random = new Random();
    
            int[] arr = new int[20];
            int[] tempArr = new int[20];
    
            for (int i = 0; i < 20; i++) {
                arr[i] = random.nextInt(100);
            }
    
            printArray(arr);
    
            mergeSort(arr, tempArr, 0, 19);
        }
    
        public static void mergeSort(int[] arr, int[] tempArr, int first, int last) {
            if (first < last) {
                int middle = (first + last) / 2;
    
                mergeSort(arr, tempArr, first, middle);
                mergeSort(arr, tempArr, middle + 1, last);
    
                int left = first;
                int right  = middle + 1;
                int tempIdx = first;
    
                while(left <= middle || right <= last) {
                    if (right > last || (arr[left] <= arr[right] && left <= middle)) {
                        tempArr[tempIdx++] = arr[left++];
                    } else {
                        tempArr[tempIdx++] = arr[right++];
                    }
                }
    
                for (int i = first; i <= last; i++) {
                    arr[i] = tempArr[i];
                }
    
                printArray(arr);
            }
    
        }
    }
    ```
    
    65 65 1 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    65 65 1 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 66 97 60 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 66 60 97 22 19 26 65 93 16 87 61 63 74  
    1 65 65 78 96 10 30 60 66 97 22 19 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 22 19 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 87 61 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 61 87 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 61 87 63 74  
    1 10 30 60 65 65 66 78 96 97 19 22 26 65 93 16 61 63 74 87  
    1 10 30 60 65 65 66 78 96 97 16 19 22 26 61 63 65 74 87 93  
    1 10 16 19 22 26 30 60 61 63 65 65 65 66 74 78 87 93 96 97  
    

병합 정렬의 시간 복잡도는 높이는 2log2n, 성분의 개수는 n개이므로 2nlog2n 즉, O(nlog2n)이다.