

Charls Antony Richard Hoare가 제안한 정렬 알고리즘. 재귀 함수(Recursive Function)을 사용한다.

다른 원소와 비교를 통해 정렬하는 비교 정렬.

퀵 정렬 함수의 요소

pivot: 데이터의 기준이 되는 수(배열의 첫번째 수)

first: pivot 다음의 수. pivot보다 큰 값을 찾는다.

last: 배열의 마지막 수. pivot보다 작은 값을 찾는다.

ex) 3 6 1 5 2 → pivot = arr[0] = 3, first = arr[1] = 6, last = arr[4] = 2

|   |   |   |   |   |
|---|---|---|---|---|
|0|1|2|3|4|
|3|6|1|5|2|

first와 last를 구하면 둘의 값을 교환한다.(first = 1, last = 4)

|   |   |   |   |   |
|---|---|---|---|---|
|0|1|2|3|4|
|3|2|1|5|6|

이후, first = 2,와 last = 3일 때 조건을 만족하지 않고 first = 3, last = 2가 된다. first가 last보다 커지면 pivot과 last의 값을 교환한다.

|   |   |   |   |   |
|---|---|---|---|---|
|0|1|2|3|4|
|1|2|3|5|6|

pivot인 2번째 값은 정렬이 끝났다. 이제 pivot보다 작은 값들끼리, pivot보다 큰 값들끼리 다시 정렬하면 된다.

- 퀵 정렬 코드
    
    ```Java
    public class QuickSort extends Sort {
        public static void main(String[] args) {
            Random random = new Random();
    
            int[] arr = new int[20];
    
            for (int i = 0; i < 20; i++) {
                arr[i] = random.nextInt(100);
            }
    
            printArray(arr);
    
            quickSort(arr, 0, 19);
        }
    
        public static void quickSort(int[] arr, int first, int last) {
            if (first >= last) return;
    
            int pivotIdx = first;
            int left = first + 1;
            int right = last;
    
            System.out.println("    pivot: " + arr[pivotIdx]);
    
            while (left <= right) {
                while (left <= last && arr[pivotIdx] >= arr[left]) left++;
                while (right > first && arr[pivotIdx] <= arr[right]) right--;
    
                if (left > right) {
                    int temp = arr[pivotIdx];
                    arr[pivotIdx] = arr[right];
                    arr[right] = temp;
                } else {
                    int temp = arr[left];
                    arr[left] = arr[right];
                    arr[right] = temp;
                }
            }
            printArray(arr);
    
            quickSort(arr, first, right - 1);
            quickSort(arr, right + 1, last);
        }
    }
    ```
    
    74 33 95 88 16 30 17 80 37 56 99 37 38 39 64 60 76 67 69 32  
    pivot: 74  
    64 33 32 69 16 30 17 67 37 56 60 37 38 39 74 99 76 80 88 95  
    pivot: 64  
    37 33 32 39 16 30 17 38 37 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 37  
    30 33 32 17 16 37 39 38 37 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 30  
    17 16 30 32 33 37 39 38 37 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 17  
    16 17 30 32 33 37 39 38 37 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 32  
    16 17 30 32 33 37 39 38 37 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 39  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 37  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 56  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 67  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 99 76 80 88 95  
    pivot: 99  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 95 76 80 88 99  
    pivot: 95  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 88 76 80 95 99  
    pivot: 88  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 80 76 88 95 99  
    pivot: 80  
    16 17 30 32 33 37 37 38 39 56 60 64 67 69 74 76 80 88 95 99  
    

퀵 정렬의 시간 복잡도 너비는 n개, 높이는 2로 계속 나누기 때문에 log2n, 즉 O(nlog2n)이다.