  

인터넷에 연결돼 있고 통신 작업이 백그라운드에서 이뤄지는 요즘엔 멀티태스킹이 필수가 됐다. 멀티태스킹이 진행되는 동안 서로의 메모리가 침범(버그 발생)할 수 있다. 이를 메모리 관리 장치라는 복잡한 하드웨어를 통해 막을 수 있다.

## 메모리 관리 장치

MMU(Memory Management Unit)

![[Untitled 40.png|Untitled 40.png]]

프로그램 —— 가상 주소 ——> MMU —— 물리 주소——> 메모리

  

MMU가 들어있는 시스템은 가상(virtual) 주소와 물리(physical) 주소를 구분한다.

MMU는 가상 주소를 물리 주소로 변환한다.

  

언뜻 보면 인덱스 레지스터와 유사해 보이지만 다르다.

MMU는 가상 메모리 주소를 두 부분으로 나눌 수 있는데 LSB쪽 부분은 물리적 주소 범위와 같고 MSB 쪽은 RAM 영역을 통해 주소를 변환한다.

이 때문에 가상 주소 범위는 물리적 메모리 주소보다 클 수 있다.

  

ex) 16비트 기계에 대한 간단한 페이지 테이블

|   |   |
|---|---|
|8bit|8bit|

MSB 쪽의 8비트는 8비트, 즉 256가지의 페이지로 분할된다. (00000000~11111111)

이로 인해 다른 메모리로 넣을 수 있고, 가상 메모리 중 일부가 같은 메모리를 사용하는 공유 메모리 기능도 사용 가능하다. 즉, 페이지 테이블은 그냥 메모리의 일부분이다.

  

![[Untitled 1 20.png|Untitled 1 20.png]]

  

즉, MMU는 프로그램의 가상 주소를 물리 메모리 주소로 변환한다.

하지만 64비트라면 어떨까?

32비트의 페이지 테이블을 사용하고, 4GiB의 페이지 테이블이 필요할 것이다. 현재도 많은 프로그램들의 물리 메모리는 4GiB정돈데, 이러한 페이지 구성은 실용적이지가 않다.

따라서 현재 MMU는 페이지 테이블 크기가 정해져있다. 전체 페이지 테이블 항목은 주 메모리에 저장되거나 주 메모리 공간이 부족하면 디스크에 저장된다. MMU는 일부를 필요할 때만 자신의 페이지 테이블로 불러와 읽어온다.

  

프로그램이 실수로 명령어를 실행시키는 것을 방지하기 위해 실행 불가 비트와 읽기 전용 비트가 존재한다.

프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트(Page Fault) 예외가 발생하는데, 스택 오버플로가 발생할 때 유용하게 사용할 수 있다. 페이지 폴트 예외가 발생하면 OS는 프로그램을 중단 시키는 것 대신 MMU가 추가 메모리를 할당해 스택 공간을 늘리고 프로그램 실행을 계속 할 수 있다.

  

  

MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어졌다.

단일 메모리 버스만 사용하는 폰 노이만 구조의 시스템도 명령어 메모리와 데이터 메모리를 분리해 제공할 수 있다.