메모리에서 가져온 비트들을 명령어라고 한다.

  

![[Untitled 35.png|Untitled 35.png]]

  

## 3주소 명령어

CPU에서 가져오는 명령어 크기를 16비트라고 가정해보자.

명령어는 2개의 피연산자, 명령코드, 결과 총 4개로 이뤄져있다.

명령어 크기가 16비트니 4비트씩 나눠 가지면 좋아보인다.

하지만 각각의 코드엔 메모리의 주소가 있어서 4비트로 표현하기엔 굉장히 부족하다.

명령어를 64비트라 가정해도 최대 20비트를 할당할 수 있는데, 이 또한 부족하다.

  

다른 방법으로, DRAM 주소 지정 기법(멀티플렉싱)을 이용한다. 주소 확장 레지스터를 두고 별도의 명령어를 사용해 주소 확장 레지스터에 상위 주소를 지정한다. 이러면 시간이 더 오래 걸리고 여러 번 레지스터를 설정해야 한다.

  

3주소 명령어가 제대로 작동하지 않는 다른 이유는 세가지 메모리 위치를 한번에 지정(메모리 접근)하는데, 이 때 주소 버스와 데이터 버스가 3개씩 필요하다. CPU의 입출력 버스는 한정돼 있기 때문에 다른 클록에 작동된다. 이러면 버스가 각 3개가 있을 필요가 없다. 따라서 데이터 버스와 주소 버스를 한개씩 두고 클록을 따로 받아 메모리 장치를 공유해야 한다.

연산 결과를 다른 연산에 활용하려면 결과 메모리 장치에 있는 데이터를 다른 명령어의 피연산자 메모리 장치로 보내기 위해 별도의 명령어를 사용해야한다.

  

명령어는 피연산자 A와 피연산자 B의 내용을 저장하는 레지스터를 추가해 다음과 같이 처리한다.

ex) R = A + B

1. PC에 들어있는 주소를 사용해 명령어를 불러온다.
2. 피연산자 A에 있는 주소를 사용해 메모리에서 데이터를 읽어 피연산자 A 레지스터에 저장한다.
3. 피연산자 B에 있는 주소를 사용해 메모리에서 데이터를 읽어 피연산자 B 레지스터에 저장한다.
4. 연산 결과를 결과에 있는 주소에 값을 저장한다.

이렇게 하면 복잡해지고 한 명령어 당 4개의 클록을 사용한다.

즉, 우리는 한 클록에 한 메모리만 접근할 수 있고, 이에 맞춰 적절히 설계해야 한다.

  

## 1주소 명령어

누산기(accumulator)라는 A 레지스터를 중간에 추가하는 방법이 있다. A 레지스터는 ALU 계산 결과를 저장한다. A 레지스터를 사용하려면 저장(store) 명령어를 추가해야 한다.

ex) R = A + B

1. 누산기 = A
2. 누산기 = 누산기 + B
3. R = 누산기

명령어가 늘어나서 비효율적으로 느껴질 수도 있는데, 다른 예제에서는 다르다.

ex) D = A + B + C

1주소 명령어

1. 누산기 = A
2. 누산기 = 누산기 + B
3. 누산기 + C
4. D = 누산기

3주소 명령어

1. 중간값 = A + B
2. D = 중간값 + C

  

1주소 명령어

1. 1주소 명령어의 경우 한 명령어 당 명령 코드 1개, 주소 1개가 있다.
2. 계산하면 한 명령어에 16비트, 4 명령어니 총 64비트를 사용한다.

  

3주소 명령어

1. 한 명령어 당 명령 코드 1개, 주소 3개가 있다.
2. 한 명령어 당 40비트, 2 명령어니 80비트가 된다.

  

## 주소 지정 모드

1. 직접 주소 지정(direct addressing)

이처럼 주소를 그대로 직접 지정하는 것을 직접 주소지정이라 한다.

누산기를 사용해 12비트를 주소 지정에 썼지만, 이걸론 부족하다.

  

1. 간접 주소 지정(indirect addressing)

더 많은 메모리를 사용하기 위해 만든 방법이다.

CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고 피연산자 주소를 얻을 수 있는 메모리 위치를 가르키는 주소로 사용한다.(주소의 주소)

직접 주소 지정과 간접 주소 지정만 있어도 메모리 다루기에 충분하다.

  

1. 즉시 주소 지정 모드(immediate addressing mode)

상수를 지정할 때 쓴다. 즉시 주소 지정은 주소에 해당하는 비트를 값으로 간주한다.

  

1. 예시

|   |   |   |
|---|---|---|
|메모리 주소|100|1000|
|값|1000|50|

직접 주소 지정의 경우, 불러오기(load) 100을 하면 1000을 그대로 누산기에 넣는다.

간접 주소 지정의 경우, 불러오기 100을 하면 1000번지에 있는 50을 누산기에 넣는다.

load 100을 하면 누산기에 100이 들어가게 되는 것이다.

  

## 조건 코드 명령어

덧셈 뺄셈 비교 연산 말고도 조건 코드가 있다.

1. cca: 조건 코드 레지스터의 값을 누산기로 복사
2. acc: 누산기의 값을 조건 코드 레지스터에 복사

위 둘 명령어로 조건 코드를 원하는 값으로 설정하거나 조건 코드의 값을 살펴볼 수 있다.

  

## 분기 명령어

이때까지 배운 명령어는 순서대로 실행할 수밖에 없다.

의사 결정을 내리고 코드의 일부를 실행할 수 있어야 한다. 이러한 일을 수행하는 명령어를 분기 명령어라 하고 PC값을 바꿀 수 있다.

보통 분기 명령어와 조건 코드 명령어를 같이 쓰는데, 조건에 따라 PC 값을 바꾸는 식으로 사용된다.

1. pca: 현재 PC 값을 누산기에 복사
2. apc: 누산기 값을 PC에 복사

  

![[Untitled 1 17.png|Untitled 1 17.png]]

  

## 최종 명령어 집합 구성

명령코드와 주소 말고도 주소 지정 모드가 있다.

주소 지정 모드는 3가지가 있기 때문에 2 비트를 쓴다. (네 번째 모드는 메모리와 관계없는 연산)

주소 지정 모드와 명령코드를 디코딩하면 명령어를 얻을 수 있다.